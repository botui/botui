"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[87],{7054:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var t=r(8102),o=(r(3696),r(9916));const a={},s="Error Handling and Debugging",l={unversionedId:"error-handling",id:"error-handling",title:"Error Handling and Debugging",description:"A comprehensive guide to handling errors gracefully and debugging BotUI applications effectively.",source:"@site/docs/error-handling.md",sourceDirName:".",slug:"/error-handling",permalink:"/error-handling",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Advanced Examples",permalink:"/advanced-examples"},next:{title:"Gotchas and Known Issues",permalink:"/gotchas"}},i={},c=[{value:"Common Error Scenarios",id:"common-error-scenarios",level:2},{value:"1. Bot Auto-Resolving (Hot Reload Issues)",id:"1-bot-auto-resolving-hot-reload-issues",level:3},{value:"2. Plugin Errors Breaking Bot Flow",id:"2-plugin-errors-breaking-bot-flow",level:3},{value:"3. Custom Renderer Errors",id:"3-custom-renderer-errors",level:3},{value:"4. Promise Rejection Handling",id:"4-promise-rejection-handling",level:3},{value:"Validation and Input Handling",id:"validation-and-input-handling",level:2},{value:"User Input Validation",id:"user-input-validation",level:3},{value:"Debugging Tools",id:"debugging-tools",level:2},{value:"1. Debug Plugin",id:"1-debug-plugin",level:3},{value:"2. State Inspector",id:"2-state-inspector",level:3},{value:"3. Conversation Logger",id:"3-conversation-logger",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:2},{value:"1. Performance Plugin",id:"1-performance-plugin",level:3},{value:"2. Memory Usage Monitor",id:"2-memory-usage-monitor",level:3},{value:"Error Recovery Patterns",id:"error-recovery-patterns",level:2},{value:"1. Graceful Degradation",id:"1-graceful-degradation",level:3},{value:"2. Retry Mechanisms",id:"2-retry-mechanisms",level:3},{value:"3. Health Checks",id:"3-health-checks",level:3},{value:"Testing Error Scenarios",id:"testing-error-scenarios",level:2},{value:"Unit Testing Error Conditions",id:"unit-testing-error-conditions",level:3},{value:"Best Practices",id:"best-practices",level:2}],u={toc:c},g="wrapper";function p({components:e,...n}){return(0,o.yg)(g,(0,t.A)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"error-handling-and-debugging"},"Error Handling and Debugging"),(0,o.yg)("p",null,"A comprehensive guide to handling errors gracefully and debugging BotUI applications effectively."),(0,o.yg)("h2",{id:"common-error-scenarios"},"Common Error Scenarios"),(0,o.yg)("h3",{id:"1-bot-auto-resolving-hot-reload-issues"},"1. Bot Auto-Resolving (Hot Reload Issues)"),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Problem"),": Bot seems to skip actions and resolve automatically, especially in development."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Cause"),": Multiple bot instances or hot-reload triggering effects multiple times."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Solution"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"import { useRef, useEffect } from 'react'\n\nconst MyBot = () => {\n  const botRef = useRef(null)\n  const hasStarted = useRef(false)\n\n  useEffect(() => {\n    if (!hasStarted.current) {\n      hasStarted.current = true\n      botRef.current = createBot()\n      startConversation(botRef.current)\n    }\n  }, [])\n\n  return (\n    <BotUI bot={botRef.current}>\n      <BotUIMessageList />\n      <BotUIAction />\n    </BotUI>\n  )\n}\n")),(0,o.yg)("h3",{id:"2-plugin-errors-breaking-bot-flow"},"2. Plugin Errors Breaking Bot Flow"),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Problem"),": Plugin throws error and breaks the entire conversation."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Solution"),": Implement error boundaries in plugins:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"const safePlugin = (block) => {\n  try {\n    // Your plugin logic\n    if (block.type === BOTUI_BLOCK_TYPES.MESSAGE) {\n      block.data.text = processText(block.data.text)\n    }\n    return block\n  } catch (error) {\n    console.error('Plugin error:', error, 'Block:', block)\n\n    // Add error indicator to meta\n    block.meta.pluginError = {\n      message: error.message,\n      timestamp: new Date().toISOString()\n    }\n\n    // Return original block to prevent breaking the flow\n    return block\n  }\n}\n\nmyBot.use(safePlugin)\n")),(0,o.yg)("h3",{id:"3-custom-renderer-errors"},"3. Custom Renderer Errors"),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Problem"),": Custom renderer components throw errors and crash the UI."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Solution"),": Use React Error Boundaries:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react'\n\nclass BotUIErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = { hasError: false, error: null }\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error }\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.error('BotUI Error:', error, errorInfo)\n\n    // Log to your error reporting service\n    // errorReportingService.log(error, errorInfo)\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"botui-error\">\n          <p>Something went wrong with this message.</p>\n          <details>\n            <summary>Error details</summary>\n            <pre>{this.state.error?.toString()}</pre>\n          </details>\n        </div>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\n// Wrap your custom renderers\nconst SafeCustomRenderer = (props) => (\n  <BotUIErrorBoundary>\n    <CustomRenderer {...props} />\n  </BotUIErrorBoundary>\n)\n")),(0,o.yg)("h3",{id:"4-promise-rejection-handling"},"4. Promise Rejection Handling"),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Problem"),": Unhandled promise rejections in bot flow."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Solution"),": Always handle promise rejections:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"const runBot = async (bot) => {\n  try {\n    await bot.message.add({ text: 'Starting...' })\n\n    const response = await bot.action.set(\n      { placeholder: 'Enter something' },\n      { actionType: 'input' }\n    )\n\n    // Process response\n    await bot.message.add({ text: `You entered: ${response.value}` })\n\n  } catch (error) {\n    console.error('Bot flow error:', error)\n\n    // Show error to user\n    await bot.message.add({\n      text: 'Sorry, something went wrong. Please try again.'\n    })\n\n    // Optionally restart or provide recovery options\n    await showErrorRecoveryOptions(bot)\n  }\n}\n\nconst showErrorRecoveryOptions = async (bot) => {\n  const recovery = await bot.action.set(\n    {\n      options: [\n        { label: 'Start over', value: 'restart' },\n        { label: 'Contact support', value: 'support' },\n        { label: 'Exit', value: 'exit' }\n      ]\n    },\n    { actionType: 'selectButtons' }\n  )\n\n  switch (recovery.selected.value) {\n    case 'restart':\n      await runBot(bot)\n      break\n    case 'support':\n      await bot.message.add({\n        text: 'Please contact support at support@example.com'\n      })\n      break\n    // exit case handles itself\n  }\n}\n")),(0,o.yg)("h2",{id:"validation-and-input-handling"},"Validation and Input Handling"),(0,o.yg)("h3",{id:"user-input-validation"},"User Input Validation"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"const ValidationAction = () => {\n  const bot = useBotUI()\n  const action = useBotUIAction()\n  const [value, setValue] = useState('')\n  const [errors, setErrors] = useState([])\n\n  const validators = {\n    required: (value) => value.trim() ? null : 'This field is required',\n    email: (value) => {\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n      return emailRegex.test(value) ? null : 'Please enter a valid email'\n    },\n    minLength: (min) => (value) =>\n      value.length >= min ? null : `Minimum ${min} characters required`,\n    maxLength: (max) => (value) =>\n      value.length <= max ? null : `Maximum ${max} characters allowed`,\n    pattern: (regex, message) => (value) =>\n      regex.test(value) ? null : message\n  }\n\n  const validate = (inputValue) => {\n    const rules = action.meta.validation || {}\n    const newErrors = []\n\n    Object.entries(rules).forEach(([rule, config]) => {\n      const validator = validators[rule]\n      if (!validator) return\n\n      let error\n      if (typeof config === 'boolean' && config) {\n        error = validator(inputValue)\n      } else if (typeof config === 'object') {\n        error = validator(config.value)(inputValue)\n      } else {\n        error = validator(config)(inputValue)\n      }\n\n      if (error) {\n        newErrors.push(error)\n      }\n    })\n\n    setErrors(newErrors)\n    return newErrors.length === 0\n  }\n\n  const handleSubmit = () => {\n    if (validate(value)) {\n      bot.next({ value, isValid: true })\n    }\n  }\n\n  return (\n    <div className=\"validation-input\">\n      <input\n        type={action.data.type || 'text'}\n        value={value}\n        onChange={(e) => {\n          setValue(e.target.value)\n          if (errors.length > 0) {\n            validate(e.target.value) // Re-validate on change if errors exist\n          }\n        }}\n        onBlur={() => validate(value)} // Validate on blur\n        placeholder={action.data.placeholder}\n      />\n      <button onClick={handleSubmit} disabled={errors.length > 0}>\n        Continue\n      </button>\n      {errors.length > 0 && (\n        <div className=\"validation-errors\">\n          {errors.map((error, index) => (\n            <div key={index} className=\"error\">{error}</div>\n          ))}\n        </div>\n      )}\n    </div>\n  )\n}\n")),(0,o.yg)("h2",{id:"debugging-tools"},"Debugging Tools"),(0,o.yg)("h3",{id:"1-debug-plugin"},"1. Debug Plugin"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"const debugPlugin = (enabled = true) => (block) => {\n  if (!enabled) return block\n\n  console.group(`\ud83e\udd16 BotUI Debug - ${block.type.toUpperCase()}`)\n  console.log('Block Key:', block.key)\n  console.log('Type:', block.type)\n  console.log('Data:', block.data)\n  console.log('Meta:', block.meta)\n  console.log('Full Block:', block)\n  console.groupEnd()\n\n  return block\n}\n\n// Use in development\nif (process.env.NODE_ENV === 'development') {\n  myBot.use(debugPlugin(true))\n}\n")),(0,o.yg)("h3",{id:"2-state-inspector"},"2. State Inspector"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"const StateInspector = () => {\n  const bot = useBotUI()\n  const action = useBotUIAction()\n  const messages = useBotUIMessage()\n  const [isOpen, setIsOpen] = useState(false)\n\n  if (process.env.NODE_ENV !== 'development') {\n    return null\n  }\n\n  return (\n    <div className=\"debug-inspector\">\n      <button onClick={() => setIsOpen(!isOpen)}>\n        \ud83d\udd0d Debug Inspector\n      </button>\n\n      {isOpen && (\n        <div className=\"debug-panel\">\n          <h4>Current Action</h4>\n          <pre>{JSON.stringify(action, null, 2)}</pre>\n\n          <h4>Messages ({messages.length})</h4>\n          <pre>{JSON.stringify(messages, null, 2)}</pre>\n\n          <h4>Bot Methods</h4>\n          <button onClick={() => console.log('Bot instance:', bot)}>\n            Log Bot to Console\n          </button>\n        </div>\n      )}\n    </div>\n  )\n}\n\n// Include in your app during development\n<BotUI bot={myBot}>\n  <BotUIMessageList />\n  <BotUIAction />\n  <StateInspector />\n</BotUI>\n")),(0,o.yg)("h3",{id:"3-conversation-logger"},"3. Conversation Logger"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"const ConversationLogger = () => {\n  const messages = useBotUIMessage()\n\n  useEffect(() => {\n    // Log conversation changes\n    console.log('Conversation updated:', {\n      messageCount: messages.length,\n      lastMessage: messages[messages.length - 1]\n    })\n  }, [messages])\n\n  const exportConversation = () => {\n    const conversation = {\n      timestamp: new Date().toISOString(),\n      messages: messages.map(msg => ({\n        type: msg.type,\n        data: msg.data,\n        meta: msg.meta,\n        key: msg.key\n      }))\n    }\n\n    const blob = new Blob([JSON.stringify(conversation, null, 2)], {\n      type: 'application/json'\n    })\n\n    const url = URL.createObjectURL(blob)\n    const a = document.createElement('a')\n    a.href = url\n    a.download = `conversation-${Date.now()}.json`\n    a.click()\n  }\n\n  if (process.env.NODE_ENV !== 'development') {\n    return null\n  }\n\n  return (\n    <button onClick={exportConversation}>\n      \ud83d\udce5 Export Conversation\n    </button>\n  )\n}\n")),(0,o.yg)("h2",{id:"performance-monitoring"},"Performance Monitoring"),(0,o.yg)("h3",{id:"1-performance-plugin"},"1. Performance Plugin"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"const performancePlugin = (block) => {\n  const startTime = performance.now()\n\n  // Mark the start of block processing\n  performance.mark(`botui-block-${block.key}-start`)\n\n  // Add timing info to meta\n  block.meta.performance = {\n    processedAt: new Date().toISOString(),\n    startTime\n  }\n\n  // Measure after a microtask to capture processing time\n  setTimeout(() => {\n    const endTime = performance.now()\n    performance.mark(`botui-block-${block.key}-end`)\n    performance.measure(\n      `botui-block-${block.key}`,\n      `botui-block-${block.key}-start`,\n      `botui-block-${block.key}-end`\n    )\n\n    console.log(`Block ${block.key} processed in ${endTime - startTime}ms`)\n  }, 0)\n\n  return block\n}\n\nmyBot.use(performancePlugin)\n")),(0,o.yg)("h3",{id:"2-memory-usage-monitor"},"2. Memory Usage Monitor"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"const MemoryMonitor = () => {\n  const [memoryInfo, setMemoryInfo] = useState(null)\n\n  useEffect(() => {\n    const updateMemoryInfo = () => {\n      if (performance.memory) {\n        setMemoryInfo({\n          used: Math.round(performance.memory.usedJSHeapSize / 1048576), // MB\n          total: Math.round(performance.memory.totalJSHeapSize / 1048576), // MB\n          limit: Math.round(performance.memory.jsHeapSizeLimit / 1048576) // MB\n        })\n      }\n    }\n\n    updateMemoryInfo()\n    const interval = setInterval(updateMemoryInfo, 5000)\n    return () => clearInterval(interval)\n  }, [])\n\n  if (!memoryInfo || process.env.NODE_ENV !== 'development') {\n    return null\n  }\n\n  return (\n    <div className=\"memory-monitor\">\n      <small>\n        Memory: {memoryInfo.used}MB / {memoryInfo.total}MB\n        (Limit: {memoryInfo.limit}MB)\n      </small>\n    </div>\n  )\n}\n")),(0,o.yg)("h2",{id:"error-recovery-patterns"},"Error Recovery Patterns"),(0,o.yg)("h3",{id:"1-graceful-degradation"},"1. Graceful Degradation"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"const GracefulRenderer = ({ message }) => {\n  try {\n    // Try to render complex component\n    return <ComplexCustomComponent data={message.data} />\n  } catch (error) {\n    console.warn('Complex renderer failed, falling back to simple:', error)\n\n    // Fallback to simple text rendering\n    return (\n      <div className=\"fallback-message\">\n        <p>{message.data.text || 'Message could not be displayed'}</p>\n        {message.data.fallbackText && (\n          <p><em>{message.data.fallbackText}</em></p>\n        )}\n      </div>\n    )\n  }\n}\n")),(0,o.yg)("h3",{id:"2-retry-mechanisms"},"2. Retry Mechanisms"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"const retryableAction = async (bot, actionData, actionMeta, maxRetries = 3) => {\n  let attempts = 0\n\n  while (attempts < maxRetries) {\n    try {\n      const result = await bot.action.set(actionData, actionMeta)\n      return result\n    } catch (error) {\n      attempts++\n      console.warn(`Action attempt ${attempts} failed:`, error)\n\n      if (attempts >= maxRetries) {\n        await bot.message.add({\n          text: 'Sorry, this action failed multiple times. Please try again later.'\n        })\n        throw error\n      }\n\n      await bot.message.add({\n        text: `Something went wrong. Retrying... (${attempts}/${maxRetries})`\n      })\n\n      // Wait before retry\n      await new Promise(resolve => setTimeout(resolve, 1000 * attempts))\n    }\n  }\n}\n")),(0,o.yg)("h3",{id:"3-health-checks"},"3. Health Checks"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"const HealthChecker = () => {\n  const bot = useBotUI()\n  const [health, setHealth] = useState('unknown')\n\n  const checkHealth = async () => {\n    try {\n      // Test basic bot functionality\n      await bot.message.getAll()\n      await bot.action.get()\n\n      setHealth('healthy')\n    } catch (error) {\n      console.error('Health check failed:', error)\n      setHealth('unhealthy')\n    }\n  }\n\n  useEffect(() => {\n    checkHealth()\n    const interval = setInterval(checkHealth, 30000) // Check every 30s\n    return () => clearInterval(interval)\n  }, [])\n\n  const handleReconnect = () => {\n    window.location.reload() // Simple recovery\n  }\n\n  if (health === 'unhealthy') {\n    return (\n      <div className=\"health-warning\">\n        <p>\u26a0\ufe0f Bot connection lost</p>\n        <button onClick={handleReconnect}>Reconnect</button>\n      </div>\n    )\n  }\n\n  return null\n}\n")),(0,o.yg)("h2",{id:"testing-error-scenarios"},"Testing Error Scenarios"),(0,o.yg)("h3",{id:"unit-testing-error-conditions"},"Unit Testing Error Conditions"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"import { createBot, BOTUI_BLOCK_TYPES } from 'botui'\n\ndescribe('Error Handling', () => {\n  test('plugin errors should not break bot flow', async () => {\n    const bot = createBot()\n\n    // Add a plugin that throws\n    const faultyPlugin = (block) => {\n      if (block.data.text === 'trigger error') {\n        throw new Error('Test error')\n      }\n      return block\n    }\n\n    // Wrap with error handling\n    const safePlugin = (block) => {\n      try {\n        return faultyPlugin(block)\n      } catch (error) {\n        block.meta.hasError = true\n        return block\n      }\n    }\n\n    bot.use(safePlugin)\n\n    // This should not throw\n    await bot.message.add({ text: 'trigger error' })\n\n    const messages = await bot.message.getAll()\n    expect(messages[0].meta.hasError).toBe(true)\n  })\n\n  test('should handle invalid action data gracefully', async () => {\n    const bot = createBot()\n\n    // This should not crash the bot\n    await expect(bot.action.set(null, null)).rejects.toThrow()\n\n    // Bot should still be functional\n    await bot.message.add({ text: 'Recovery test' })\n    const messages = await bot.message.getAll()\n    expect(messages).toHaveLength(1)\n  })\n})\n")),(0,o.yg)("h2",{id:"best-practices"},"Best Practices"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Always use error boundaries")," around custom renderers"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Implement graceful fallbacks")," for complex components"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Validate user input")," before processing"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Log errors")," but don't expose sensitive information"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Provide clear recovery options")," to users"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Test error scenarios")," in development"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Monitor performance")," in production"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Use debugging tools")," during development")),(0,o.yg)("p",null,"By following these patterns, you can build robust BotUI applications that handle errors gracefully and provide excellent user experiences even when things go wrong."))}p.isMDXComponent=!0},9916:(e,n,r)=>{r.d(n,{xA:()=>u,yg:()=>d});var t=r(3696);function o(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function a(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),r.push.apply(r,t)}return r}function s(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?a(Object(r),!0).forEach(function(n){o(e,n,r[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))})}return e}function l(e,n){if(null==e)return{};var r,t,o=function(e,n){if(null==e)return{};var r,t,o={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(o[r]=e[r]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var i=t.createContext({}),c=function(e){var n=t.useContext(i),r=n;return e&&(r="function"==typeof e?e(n):s(s({},n),e)),r},u=function(e){var n=c(e.components);return t.createElement(i.Provider,{value:n},e.children)},g="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef(function(e,n){var r=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),g=c(r),m=o,d=g["".concat(i,".").concat(m)]||g[m]||p[m]||a;return r?t.createElement(d,s(s({ref:n},u),{},{components:r})):t.createElement(d,s({ref:n},u))});function d(e,n){var r=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=r.length,s=new Array(a);s[0]=m;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l[g]="string"==typeof e?e:o,s[1]=l;for(var c=2;c<a;c++)s[c]=r[c];return t.createElement.apply(null,s)}return t.createElement.apply(null,r)}m.displayName="MDXCreateElement"}}]);